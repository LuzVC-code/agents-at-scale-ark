@startuml event-recording-tracking
!define ARKSTYLE
!include <awslib/AWSCommon>
!include <awslib/ApplicationIntegration/APIGateway>

' Define color scheme for ARK components
!define ARK_PRIMARY #2E86AB
!define ARK_SECONDARY #A23B72
!define ARK_ACCENT #F18F01
!define ARK_SUCCESS #C73E1D
!define ARK_NEUTRAL #F4F4F4

' Title and header information
title **Event Recording & Tracking System**\n//ARK Platform v0.1.31 - Comprehensive Observability & Telemetry//

' Define participants with proper styling
participant "Query\nController" as QC ARK_PRIMARY
participant "Operation\nTracker" as OT ARK_SECONDARY
participant "Execution\nRecorder" as ER ARK_ACCENT
participant "Event\nEmitter" as EE ARK_SUCCESS
participant "Kubernetes\nEvents" as K8sEvents ARK_NEUTRAL
participant "Token\nCollector" as TC #lightblue
participant "Monitoring\nSystem" as Monitor #lightgreen

' Main event recording flow
note over QC, Monitor
**Complete Event Recording & Tracking Architecture**
Multi-level observability with timing, token usage, and structured telemetry
end note

== 1. Operation Lifecycle Tracking ==
QC -> QC : Begin query execution
QC -> OT : NewOperationTracker(emitter, ctx, "QueryResolve", queryName, metadata)
activate OT
note right of OT : Start operation tracking:\n- Record start time\n- Initialize metadata\n- Set operation context

OT -> EE : EmitEvent(ctx, "QueryResolveStart", startEvent)
activate EE
note right of EE : Emit start event with:\n- Operation name\n- Metadata (namespace, targets)\n- Component type

EE -> K8sEvents : Create Kubernetes Event
activate K8sEvents
note right of K8sEvents : Event stored in etcd:\n- Resource reference\n- Event type: "Normal"\n- JSON structured data

== 2. Multi-Level Event Emission ==
QC -> ER : NewExecutionRecorder(emitter)
activate ER
note right of ER : High-level execution events:\n- Team strategies\n- Agent lifecycle\n- Member coordination

QC -> TC : NewTokenUsageCollector(recorder)
activate TC
note right of TC : Specialized token tracking:\n- Aggregate LLM usage\n- Cost calculation\n- Performance metrics

== 3. Structured Event Hierarchy ==
note over QC, Monitor : **Level 0 (Critical) - Always Visible**

QC -> OT : Track query resolution
OT -> EE : QueryResolveStart
EE -> K8sEvents : Critical operation event
note right of K8sEvents : Always emitted regardless of log level:\n{"name": "my-query", "namespace": "default", "targets": "2"}

note over QC, Monitor : **Level 1 (Standard) - Operational Events**

QC -> ER : AgentExecution(ctx, "Start", agentName, modelName)
ER -> EE : EmitEvent(ctx, "AgentStart", executionEvent)
EE -> K8sEvents : Agent lifecycle event
note right of K8sEvents : Emitted when verbosity >= 1:\n{"name": "my-agent", "model": "gpt-4", "component": "agent"}

QC -> ER : TeamMember(ctx, "Start", teamName, memberType, memberName, turn)
ER -> EE : EmitEvent(ctx, "TeamMemberStart", memberEvent)
EE -> K8sEvents : Team member execution event
note right of K8sEvents : Team coordination tracking:\n{"team": "dev-team", "memberType": "agent", "turn": "1"}

note over QC, Monitor : **Level 2 (Detailed) - Debug Information**

QC -> OT : Track LLM call
OT -> EE : LLMCallStart
EE -> K8sEvents : LLM interaction start
QC -> OT : CompleteWithTokens(result, tokenUsage)
OT -> EE : LLMCallComplete with token data
EE -> K8sEvents : LLM completion with metrics
note right of K8sEvents : Detailed operation tracking:\n{"duration": "2.5s", "tokens": 150, "model": "gpt-4"}

== 4. Token Usage Aggregation ==
OT -> TC : EmitEvent(ctx, "LLMCallComplete", operationEvent)
TC -> TC : Collect token usage from OperationEvent
note right of TC : Aggregate token metrics:\n- PromptTokens: sum across calls\n- CompletionTokens: total responses\n- TotalTokens: overall usage

TC -> TC : Maintain running totals
note right of TC : Track cumulative usage:\n- Per query session\n- Per agent execution\n- Per team coordination

alt if token usage significant
    TC -> EE : EmitEvent(ctx, "TokenUsageUpdate", aggregatedData)
    EE -> K8sEvents : Token usage milestone event
end

== 5. Error & Exception Tracking ==
alt if operation fails
    QC -> OT : Fail(error)
    OT -> EE : EmitEvent(ctx, "QueryResolveError", errorEvent)
    EE -> K8sEvents : Error event with details
    note right of K8sEvents : Error tracking:\n{"error": "connection timeout", "duration": "30s"}
end

alt if graceful termination
    QC -> OT : CompleteWithTermination(terminationMessage)
    OT -> EE : EmitEvent(ctx, "QueryResolveComplete", terminationEvent)
    EE -> K8sEvents : Termination event
    note right of K8sEvents : Controlled termination:\n{"terminationMessage": "user requested stop"}
end

== 6. Event Processing & Storage ==
EE -> EE : Validate event data structure
note right of EE : Event validation:\n- Required fields present\n- Metadata format correct\n- Resource references valid

EE -> EE : Marshal event data to JSON
note right of EE : Structured data conversion:\n- BaseEvent fields\n- Operation-specific data\n- Timing information

K8sEvents -> K8sEvents : Store event in etcd
note right of K8sEvents : Persistent event storage:\n- Associated with CRD resource\n- Searchable by type and time\n- Available via kubectl events

K8sEvents -> Monitor : Event stream for monitoring
activate Monitor
note right of Monitor : External monitoring integration:\n- Prometheus metrics\n- Grafana dashboards\n- Alert manager rules

== 7. Completion & Cleanup ==
QC -> OT : Complete(result) / CompleteWithTokens(result, tokens)
OT -> OT : Calculate operation duration
note right of OT : Performance metrics:\n- Start time to completion\n- Operation success/failure\n- Resource utilization

OT -> EE : EmitEvent(ctx, "QueryResolveComplete", completionEvent)
EE -> K8sEvents : Final completion event
note right of K8sEvents : Operation summary:\n{"duration": "45.2s", "totalTokens": 2847, "status": "success"}

deactivate OT
deactivate ER
deactivate TC
deactivate EE
deactivate K8sEvents
deactivate Monitor

== 8. Event Retrieval & Analysis ==
Monitor -> K8sEvents : Query events for analysis
K8sEvents -> Monitor : Event history and metrics

note over Monitor : **Monitoring Capabilities:**
Monitor -> Monitor : Performance dashboard creation
note right of Monitor : Real-time metrics:\n- Average query duration\n- Token usage trends\n- Error rates by component

Monitor -> Monitor : Alert rule evaluation
note right of Monitor : Automated alerting:\n- High error rates\n- Excessive token usage\n- Performance degradation

Monitor -> Monitor : Cost analysis
note right of Monitor : Resource tracking:\n- LLM API costs\n- Token consumption patterns\n- Efficiency metrics

note over QC, Monitor
**Key Features:**
• **Hierarchical Verbosity**: 3 levels of detail (Critical, Standard, Detailed)
• **Structured Events**: JSON format with metadata and timing
• **Token Aggregation**: Comprehensive usage tracking and cost analysis
• **Operation Lifecycle**: Start, progress, completion, and error tracking
• **Kubernetes Integration**: Native event storage and retrieval
• **Monitoring Ready**: Prometheus/Grafana compatible metrics
• **Error Resilience**: Graceful handling of recording failures
• **Performance Tracking**: Duration and resource utilization metrics
end note

@enduml
